$date
	Tue Dec  2 11:00:38 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module core_tb $end
$var wire 32 ! pc_addr [31:0] $end
$var wire 32 " instr [31:0] $end
$var reg 1 # clk $end
$var reg 1 $ rst_n $end
$scope module u_core $end
$var wire 1 # clk $end
$var wire 32 % pc_addr [31:0] $end
$var wire 1 & reg_write $end
$var wire 1 $ rst_n $end
$var wire 32 ' wdata [31:0] $end
$var wire 32 ( rs2_data [31:0] $end
$var wire 5 ) rs2 [4:0] $end
$var wire 32 * rs1_data [31:0] $end
$var wire 5 + rs1 [4:0] $end
$var wire 5 , rd [4:0] $end
$var wire 32 - pc_next [31:0] $end
$var wire 32 . pc_curr [31:0] $end
$var wire 7 / opcode [6:0] $end
$var wire 1 0 is_u_type $end
$var wire 1 1 is_s_type $end
$var wire 1 2 is_r_type $end
$var wire 1 3 is_j_type $end
$var wire 1 4 is_i_type $end
$var wire 1 5 is_b_type $end
$var wire 32 6 instr [31:0] $end
$var wire 7 7 funct7 [6:0] $end
$var wire 3 8 funct3 [2:0] $end
$scope module u_decoder $end
$var wire 1 4 is_i_type $end
$var wire 1 0 is_u_type $end
$var wire 5 9 rs2 [4:0] $end
$var wire 5 : rs1 [4:0] $end
$var wire 5 ; rd [4:0] $end
$var wire 7 < opcode [6:0] $end
$var wire 1 1 is_s_type $end
$var wire 1 2 is_r_type $end
$var wire 1 3 is_j_type $end
$var wire 1 5 is_b_type $end
$var wire 32 = instr [31:0] $end
$var wire 7 > funct7 [6:0] $end
$var wire 3 ? funct3 [2:0] $end
$upscope $end
$scope module u_pc $end
$var wire 1 # clk $end
$var wire 32 @ din [31:0] $end
$var wire 1 $ rst_n $end
$var reg 32 A dout [31:0] $end
$upscope $end
$scope module u_regfile $end
$var wire 1 # clk $end
$var wire 5 B rd_addr [4:0] $end
$var wire 5 C rs1_addr [4:0] $end
$var wire 5 D rs2_addr [4:0] $end
$var wire 32 E wdata [31:0] $end
$var wire 1 & we $end
$var wire 32 F rs2_data [31:0] $end
$var wire 32 G rs1_data [31:0] $end
$var integer 32 H i [31:0] $end
$upscope $end
$upscope $end
$scope module u_imem $end
$var wire 32 I addr [31:0] $end
$var wire 32 J data [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b10011 J
b0 I
b100000 H
b0 G
b0 F
b11011110101011011011111011101111 E
b0 D
b0 C
b0 B
b0 A
b100 @
b0 ?
b0 >
b10011 =
b10011 <
b0 ;
b0 :
b0 9
b0 8
b0 7
b10011 6
05
14
03
02
01
00
b10011 /
b0 .
b100 -
b0 ,
b0 +
b0 *
b0 )
b0 (
b11011110101011011011111011101111 '
1&
b0 %
0$
0#
b10011 "
b0 !
$end
#5000
1#
#10000
0#
#15000
1#
#20000
0#
1$
#25000
b1 )
b1 9
b1 D
b1 ,
b1 ;
b1 B
b100000000000010010011 "
b100000000000010010011 6
b100000000000010010011 =
b100000000000010010011 J
b1000 -
b1000 @
b100 !
b100 %
b100 I
b100 .
b100 A
1#
#30000
0#
#35000
04
b11011110101011011011111011101111 *
b11011110101011011011111011101111 G
b10 )
b10 9
b10 D
b1 +
b1 :
b1 C
b10 ,
b10 ;
b10 B
12
b110011 /
b110011 <
b1000001000000100110011 "
b1000001000000100110011 6
b1000001000000100110011 =
b1000001000000100110011 J
b0 (
b0 F
b1100 -
b1100 @
b1000 !
b1000 %
b1000 I
b1000 .
b1000 A
1#
#40000
0#
#45000
x&
bx *
bx G
x4
x0
bx 7
bx >
bx )
bx 9
bx D
bx +
bx :
bx C
bx 8
bx ?
bx ,
bx ;
bx B
x2
x1
x5
x3
bx /
bx <
bx "
bx 6
bx =
bx J
bx (
bx F
b10000 -
b10000 @
b1100 !
b1100 %
b1100 I
b1100 .
b1100 A
1#
#50000
0#
#55000
b10100 -
b10100 @
b10000 !
b10000 %
b10000 I
b10000 .
b10000 A
1#
#60000
0#
#65000
b11000 -
b11000 @
b10100 !
b10100 %
b10100 I
b10100 .
b10100 A
1#
#70000
0#
#75000
b11100 -
b11100 @
b11000 !
b11000 %
b11000 I
b11000 .
b11000 A
1#
#80000
0#
#85000
b100000 -
b100000 @
b11100 !
b11100 %
b11100 I
b11100 .
b11100 A
1#
#90000
0#
#95000
b100100 -
b100100 @
b100000 !
b100000 %
b100000 I
b100000 .
b100000 A
1#
#100000
0#
#105000
b101000 -
b101000 @
b100100 !
b100100 %
b100100 I
b100100 .
b100100 A
1#
#110000
0#
#115000
b101100 -
b101100 @
b101000 !
b101000 %
b101000 I
b101000 .
b101000 A
1#
#120000
0#
